<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NAS（5）—— 数据冗余保障 | Dean's Blog</title><meta name="author" content="Dean Ma"><meta name="copyright" content="Dean Ma"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="回到目录  硬盘健康监测 SMART S.M.A.R.T. 代表的是 Self-Monitoring Analysis and Reporting Technology，意思是自我检测、分析及报告技术。可以用来预测和分析硬盘的潜在问题。 对于机械硬盘（HDD）的寿命信息，我们主要关注这几个条目：  重新分配扇区系数（05） 当前等待中扇区数（C5） 无法修正的扇区总数（C6，重要，不为零即建议备份">
<meta property="og:type" content="article">
<meta property="og:title" content="NAS（5）—— 数据冗余保障">
<meta property="og:url" content="https://blog.dawnocean.site/NAS-5">
<meta property="og:site_name" content="Dean&#39;s Blog">
<meta property="og:description" content="回到目录  硬盘健康监测 SMART S.M.A.R.T. 代表的是 Self-Monitoring Analysis and Reporting Technology，意思是自我检测、分析及报告技术。可以用来预测和分析硬盘的潜在问题。 对于机械硬盘（HDD）的寿命信息，我们主要关注这几个条目：  重新分配扇区系数（05） 当前等待中扇区数（C5） 无法修正的扇区总数（C6，重要，不为零即建议备份">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.dawnocean.site/assets/img/kirby_cover20.JPG">
<meta property="article:published_time" content="2024-08-25T18:43:31.000Z">
<meta property="article:modified_time" content="2025-09-02T16:21:45.870Z">
<meta property="article:author" content="Dean Ma">
<meta property="article:tag" content="dean,dawn_ocean,dawn1ocean,晓洋,博客,furry,NAS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.dawnocean.site/assets/img/kirby_cover20.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "NAS（5）—— 数据冗余保障",
  "url": "https://blog.dawnocean.site/NAS-5",
  "image": "https://blog.dawnocean.site/assets/img/kirby_cover20.JPG",
  "datePublished": "2024-08-25T18:43:31.000Z",
  "dateModified": "2025-09-02T16:21:45.870Z",
  "author": [
    {
      "@type": "Person",
      "name": "Dean Ma",
      "url": "https://blog.dawnocean.site"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/img/avatar.jpg"><link rel="canonical" href="https://blog.dawnocean.site/NAS-5"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-GQcRECGqLJ"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Dean Ma","link":"链接: ","source":"来源: Dean's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NAS（5）—— 数据冗余保障',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/NAS-Router-0"><i class="fa-fw fas fa-computer"></i><span> 硬路由 / NAS</span></a></li><li><a class="site-page child" href="/Furry-1"><i class="fa-fw fas fa-paw"></i><span> Furry 杂谈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/img/kirby_cover20.JPG);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/assets/img/avatar.jpg" alt="Logo"><span class="site-name">Dean's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">NAS（5）—— 数据冗余保障</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/NAS-Router-0"><i class="fa-fw fas fa-computer"></i><span> 硬路由 / NAS</span></a></li><li><a class="site-page child" href="/Furry-1"><i class="fa-fw fas fa-paw"></i><span> Furry 杂谈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">NAS（5）—— 数据冗余保障</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-25T18:43:31.000Z" title="发表于 2024-08-26 02:43:31">2024-08-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-02T16:21:45.870Z" title="更新于 2025-09-03 00:21:45">2025-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NAS/">NAS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NAS/RAID/">RAID</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><link rel="stylesheet external nofollow noreferrer" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><a href="/NAS-Router-0" title="NAS &#x2F; 硬路由：从入门到入门">回到目录</a>
<br/>
<h1 id="硬盘健康监测"><a class="header-anchor" href="#硬盘健康监测"></a>硬盘健康监测</h1>
<h2 id="smart"><a class="header-anchor" href="#smart"></a>SMART</h2>
<p>S.M.A.R.T. 代表的是 Self-Monitoring Analysis and Reporting Technology，意思是自我检测、分析及报告技术。可以用来预测和分析硬盘的潜在问题。</p>
<p>对于机械硬盘（HDD）的寿命信息，我们主要关注这几个条目：</p>
<ul>
<li>重新分配扇区系数（05）</li>
<li>当前等待中扇区数（C5）</li>
<li><strong>无法修正的扇区总数（C6，重要，不为零即建议备份数据、换盘）</strong></li>
</ul>
<p>对于固态硬盘（SSD）的寿命信息，我们主要关注这几个条目：</p>
<ul>
<li>可用备用空间（03）</li>
<li>已用寿命百分比（05）</li>
<li><strong>媒体与数据完整性错误计数（0E，重要，不为零即建议备份数据、换盘）</strong></li>
</ul>
<p>在 Windows 系统，我们可以使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://crystalmark.info/en/software/crystaldiskinfo/" title="CrystalDiskInfo">CrystalDiskInfo</a> 这款软件来查看硬盘的 Smart 信息。</p>
<p>在 Linux 系统，我们可以使用<code>smartmontools</code>包来查看硬盘的 Smart 信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install smartmontools -y</span><br></pre></td></tr></table></figure>
<p>要确保您的驱动器支持 SMART，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> smartctl -i /dev/sda</span><br></pre></td></tr></table></figure>
<p>其中<code>/dev/sda</code>一般为机械硬盘 / U 盘，固态硬盘如<code>/dev/nvme0n1p1</code>，可以通过<code>lsblk</code>命令查看各硬盘。</p>
<p>如果您的驱动器未启用 SMART，您可以通过键入以下内容来启用它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> smartctl -s on /dev/sda</span><br></pre></td></tr></table></figure>
<p>检查硬盘整体健康状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> smartctl -H /dev/sda</span><br></pre></td></tr></table></figure>
<p>此命令应返回：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=== START OF READ SMART DATA SECTION ===</span><br><span class="line">SMART overall-health self-assessment test result: PASSED</span><br></pre></td></tr></table></figure>
<p>如果它没有返回 PASSED，您应该立即备份所有数据。您的硬盘驱动器可能出现故障。</p>
<h2 id="scrutiny"><a class="header-anchor" href="#scrutiny"></a>Scrutiny</h2>
<p>Scrutiny 是用于smartd 监控硬盘 S.M.A.R.T 信息的 WebUI。</p>
<p><img src="NAS-5/image_v5JOICGCKw.png" alt=""></p>
<h3 id="通过-docker-部署"><a class="header-anchor" href="#通过-docker-部署"></a>通过 Docker 部署</h3>
<p>可以先阅读<a href="/NAS-7" title="NAS（7）—— Docker 服务">Docker 服务</a>部分，将 NAS 上的 Docker 环境配置完成。</p>
<p>使用 Docker Compose：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.5&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">scrutiny:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ghcr.io/analogj/scrutiny:master-omnibus</span></span><br><span class="line">      <span class="attr">container_name:</span> <span class="string">scrutiny</span></span><br><span class="line">      <span class="attr">cap_add:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SYS_RAWIO</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PUID=1001</span> <span class="comment"># PUID 与 PGID 请根据实际情况设置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PGID=100</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/srv/dockerapps/scrutiny/config:/config</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/run/udev:/run/udev:ro</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/srv/dockerapps/scrutiny/influxdb:/opt/scrutiny/influxdb</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;8082:8080&quot;</span> <span class="comment"># 端口请根据实际情况设置，8080 为 Web 端口</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;8086:8086&quot;</span> <span class="comment"># 8086 为 InfluxDB 数据库端口</span></span><br><span class="line">      <span class="attr">devices:</span>     </span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/dev/sda&quot;</span> <span class="comment"># 通过 lsblk 命令查看硬盘</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/dev/sdb&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/dev/sdc&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/dev/nvme0n1&quot;</span></span><br><span class="line">      <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>
<p>服务启动后访问对应端口即可查看硬盘详细信息。记得开放防火墙对应端口。</p>
<p><img src="NAS-5/image_38Or3UI6Wm.png" alt=""></p>
<h1 id="系统备份"><a class="header-anchor" href="#系统备份"></a>系统备份</h1>
<h2 id="snapper-btrfs"><a class="header-anchor" href="#snapper-btrfs"></a>Snapper - Btrfs</h2>
<blockquote>
<p>关于 Btrfs 的配置笔者还是有很多不清楚的地方，建议除了 snapshots 的更改不要创建任何子卷，手动写 snapper 配置忽略目录（虽然快照还是会保存）。</p>
</blockquote>
<p>此部分主要来自于<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhiim.github.io/p/arch-linux-configuration-btrfs-and-system-backup">这篇文章</a>。</p>
<p>Btrfs 默认采用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/copy-on-write">CoW</a> 机制，将文件指针存放在 metadata 文件中。在对文件进行更改时，Btrfs 会将新的数据写在新的空闲数据块中，数据写入完成后，更新 metadata 增加将文件指向新的内存块的指针。</p>
<p>Snapper 是一个免费的开源应用程序，我们可以使用它来管理 Linux 上的快照。它最初设计为与 Btrfs 快照一起使用，但已扩展为还支持 LVM 精简配置逻辑卷。</p>
<h3 id="安装"><a class="header-anchor" href="#安装"></a>安装</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install snapper</span><br></pre></td></tr></table></figure>
<h3 id="改变快照存储位置"><a class="header-anchor" href="#改变快照存储位置"></a>改变快照存储位置</h3>
<p>Snapper 默认把快照存储在<code>@</code>子卷内的<code>.snapshots</code>分卷下，如果<code>@</code>子卷损坏，<code>.snapshots</code>也可能受影响，所以更好的子卷结构是把快照存储在<code>@snapshots</code>子卷下，然后把<code>@snapshots</code>挂载在根子卷下，这样<code>@</code>和<code>@snapshots</code>互不影响。</p>
<p>删除默认的<code>.snapshots</code>子卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> btrfs subvolume list /</span><br><span class="line">ID 256 gen 7144 top level 5 path @</span><br><span class="line">ID 257 gen 7144 top level 5 path @home</span><br><span class="line">ID 258 gen 17 top level 256 path var/lib/portables</span><br><span class="line">ID 259 gen 18 top level 256 path var/lib/machines</span><br><span class="line">ID 266 gen 7115 top level 256 path .snapshots</span><br><span class="line">ID 267 gen 6963 top level 266 path .snapshots/1/snapshot</span><br><span class="line">ID 272 gen 6995 top level 266 path .snapshots/2/snapshot</span><br><span class="line"><span class="comment"># 如果已经有快照，需要先删除.snapshots里面的快照子卷</span></span><br><span class="line">❯ <span class="built_in">sudo</span> btrfs subvolume delete .snapshots/1/snapshot</span><br><span class="line">Delete subvolume (no-commit): <span class="string">&#x27;/.snapshots/1/snapshot&#x27;</span></span><br><span class="line">❯ <span class="built_in">sudo</span> btrfs subvolume delete .snapshots/2/snapshot</span><br><span class="line">Delete subvolume (no-commit): <span class="string">&#x27;/.snapshots/2/snapshot&#x27;</span></span><br><span class="line">❯ <span class="built_in">sudo</span> btrfs subvolume delete .snapshots</span><br><span class="line">Delete subvolume (no-commit): <span class="string">&#x27;//.snapshots&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在根子卷下并列<code>@</code>子卷创建一个<code>@snapshots</code>子卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/rootsub</span><br><span class="line"><span class="built_in">sudo</span> mount -o subvolid=5 /dev/nvme0n1p6 ~/rootsub  <span class="comment"># 挂载根子卷</span></span><br><span class="line"><span class="built_in">sudo</span> btrfs subvolume create ~/rootsub/@snapshots  <span class="comment"># 在根子卷下创建子卷</span></span><br></pre></td></tr></table></figure>
<p>编辑<code>/etc/fstab</code>，将<code>@subvolume</code>子卷挂载到<code>/.snapshots</code>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 仿照 / 的挂载更改，UUID 与根目录的 UUID 一致</span><br><span class="line">UUID=d26ed334-68d4-481d-894f-838783fa4f88  /.snapshots  btrfs  rw,relatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvol=/@snapshots  0 0</span><br></pre></td></tr></table></figure>
<p>挂载<code>@snapshots</code>子卷：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /.snapshots</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo mount -a</span><br><span class="line">sudo chmod 750 /.snapshots  # 阻止非 root 用户访问</span><br></pre></td></tr></table></figure>
<h3 id="创建快照"><a class="header-anchor" href="#创建快照"></a>创建快照</h3>
<p>第一次创建快照时，我们先要创建配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snapper -c root create-config / <span class="comment"># 为挂载在根目录下的子卷创建命名为 root 的快照配置文件</span></span><br></pre></td></tr></table></figure>
<p>此时 Snapper 会在<code>/etc/snapper/configs</code>生成配置文件，并且在根目录<code>/</code>挂载的子卷即<code>@</code>下创建<code>.snapshots</code>子卷，所有快照都会存储在<code>.snapshots</code>子卷下。</p>
<p>Snapper 可以自动创建和清除快照，默认会每小时创建一个快照，每天清理一次快照，在清理时会保存 10 个每小时快照、10 个每日快照、10 个每月快照、10 个每年快照。</p>
<p>开启 Snapper 自动快照和自动清理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now snapper-timeline.timer</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now snapper-cleanup.timer</span><br></pre></td></tr></table></figure>
<p>手动创建快照：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snapper -c &lt;快照配置文件名&gt; create --description=&lt;description&gt; -p </span><br></pre></td></tr></table></figure>
<h3 id="回滚快照-仅用于非根目录"><a class="header-anchor" href="#回滚快照-仅用于非根目录"></a>回滚快照（仅用于非根目录）</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snapper -c &lt;快照配置文件名&gt; undochange &lt;num1&gt;..&lt;num0&gt;</span><br></pre></td></tr></table></figure>
<p>这条指令向 btrfs 卷施加从 num0 到 num1 的差异。一般用法是 x…0（表示从当前状态回滚到快照 x）。</p>
<h3 id="备份到外部存储"><a class="header-anchor" href="#备份到外部存储"></a>备份到外部存储</h3>
<p>我们可以使用 Snapper 自带的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://man.archlinux.org/man/snbk.8.en">snbk 工具</a>。</p>
<h3 id="从快照恢复"><a class="header-anchor" href="#从快照恢复"></a>从快照恢复</h3>
<p>假设我们已经为<code>/</code>创建了快照，如果想要从快照中恢复系统，可以先进入 Live USB，然后挂载 Btrfs 分区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount /dev/nvmexn1px /mnt</span><br><span class="line"><span class="built_in">cd</span> /mnt</span><br></pre></td></tr></table></figure>
<p>移除旧的<code>@</code>子卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /mnt/@ /mnt/@.broken</span><br></pre></td></tr></table></figure>
<p>列出所有快照和对应的时间信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> grep -r <span class="string">&#x27;&lt;date&gt;&#x27;</span> /mnt/@snapshots/*/info.xml</span><br><span class="line">/.snapshots/1/info.xml:  &lt;<span class="built_in">date</span>&gt;2023-07-11 06:21:53&lt;/date&gt;  <span class="comment"># Snapper 使用 UTC 时间记录快照创建时间</span></span><br><span class="line">/.snapshots/2/info.xml:  &lt;<span class="built_in">date</span>&gt;2022-07-11 06:22:39&lt;/date&gt;</span><br></pre></td></tr></table></figure>
<p>由于 Snapper 创建的快照是只读子卷，所以需要从快照中创建可读写快照作为<code>@</code>子卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> btrfs subvolume snapshot /mnt/@snapshots/&lt;number&gt;/snapshot /mnt/@</span><br></pre></td></tr></table></figure>
<h2 id="timeshift-所有文件系统"><a class="header-anchor" href="#timeshift-所有文件系统"></a>Timeshift - 所有文件系统</h2>
<p>Timeshift 可帮助定期创建文件系统的增量快照，然后在以后恢复到这些快照，以撤销对系统的所有更改。</p>
<p>它支持针对所有文件系统的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://wiki.archlinuxcn.org/wiki/Rsync">rsync</a> 快照，也可使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://wiki.archlinuxcn.org/wiki/Btrfs">Btrfs</a> 驱动器的内置快照功能，这需要驱动器根目录和<code>home</code>目录分别使用<code>@</code>和<code>@home</code>子卷布局配置。</p>
<p>Timeshift 还附带便于使用的 GUI，使得用户可以通过图形化界面直接进行备份操作。</p>
<p><img src="NAS-5/image_m9y338N_7w.png" alt=""></p>
<h3 id="安装"><a class="header-anchor" href="#安装"></a>安装</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install timeshift</span><br></pre></td></tr></table></figure>
<p>配置 TimeShift 时，可以编辑<code>/etc/timeshift/timeshift.json</code>文件，将“备份设备”设置为适合的磁盘，并根据需求修改快照的<code>exclude</code>（排除）项。</p>
<p>示例配置文件内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;backup_device_uuid&quot;:</span> <span class="string">&quot;YOUR-DEVICE-UUID&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;btrfs_mode&quot;:</span> <span class="string">&quot;false&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;schedule_daily&quot;:</span> <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;count_daily&quot;:</span> <span class="string">&quot;5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;exclude&quot;:</span> [</span><br><span class="line">    <span class="string">&quot;/home/**&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/root/**&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建快照"><a class="header-anchor" href="#创建快照"></a>创建快照</h3>
<p>首先执行一次完整快照：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> timeshift --create --comments <span class="string">&quot;Initial Snapshot&quot;</span> --tags D</span><br></pre></td></tr></table></figure>
<p>使用以下命令查看当前快照：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> timeshift --list</span><br></pre></td></tr></table></figure>
<p>可以使用<code>--delete</code>参数删除旧快照，释放空间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> timeshift --delete --snapshot <span class="string">&quot;Name（时间）&quot;</span></span><br><span class="line"><span class="comment"># 如下：</span></span><br><span class="line"><span class="built_in">sudo</span> timeshift --delete --snapshot <span class="string">&#x27;2024-11-11_17-23-52&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="从快照恢复"><a class="header-anchor" href="#从快照恢复"></a>从快照恢复</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> timeshift --restore --snapshot <span class="string">&quot;Name（时间）&quot;</span></span><br><span class="line"><span class="comment"># 如下：</span></span><br><span class="line"><span class="built_in">sudo</span> timeshift --restore --snapshot <span class="string">&#x27;2024-11-11_17-23-52&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="raid"><a class="header-anchor" href="#raid"></a>RAID</h1>
<p>使用 RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列），可以大幅提高硬盘设备的 I/O 读写速度，还有各种数据冗余备份机制供用户选择，能够降低用户数据盘损坏带来的数据丢失的风险。</p>
<p>RAID 技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。</p>
<h2 id="软-raid-和硬-raid"><a class="header-anchor" href="#软-raid-和硬-raid"></a>软 RAID 和硬 RAID</h2>
<p>软件 RAID 是通过操作系统的软件来实现 RAID 功能。软件 RAID 不需要额外的硬件控制器，而是依赖于操作系统的 RAID 驱动程序，通过 CPU 处理 RAID 相关的计算和数据操作。</p>
<p>硬件 RAID 是通过在独立的硬件控制器上实现 RAID 功能。硬件控制器通常是一块专用的 RAID 卡，通过硬件来管理 RAID 阵列，包括数据读写、磁盘故障检测和数据恢复等。</p>
<p>相比于硬 RAID，软 RAID 有三个明显的缺点：</p>
<ul>
<li>占用内存空间</li>
<li>占用 CPU 资源</li>
<li>软件的 RAID 程序无法将已经安装了操作系统的磁盘也做成 RAID</li>
</ul>
<p>最后一点意味着，软 RAID 只有在操作系统成功启动后才能运行，如果运行过程中操作系统崩溃，组成 RAID 的磁盘中的数据将无法读写。</p>
<p>但在实际的使用过程中，硬 RAID 需要配备相应的硬件，配置的时间成本和花费都较高，在日常使用的情况下，我们通常采用软 RAID 方案即可。</p>
<h2 id="raid-种类"><a class="header-anchor" href="#raid-种类"></a>RAID 种类</h2>
<p>这一部分主要参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/kuangdaoyizhimei/p/18314827" title="这篇文章">这篇文章</a>。</p>
<h3 id="raid-0"><a class="header-anchor" href="#raid-0"></a>RAID 0</h3>
<p>RAID 0 技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障，将导致整个系统的数据都受到破坏。通俗来说，RAID 0 技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据误修复能力。</p>
<p>如下图所示，数据被分别写入到不同的硬盘设备中，两块硬盘会分别保存数据资料，最终实现提升读取、写入速度的效果。</p>
<p><img src="NAS-5/image_z7GasqjUZW.png" alt=""></p>
<ul>
<li>最少需要的硬盘数：2</li>
<li>优点：更快的数据访问</li>
<li>缺点：没有硬盘冗余，所以数据丢失的风险会增加。未针对不同容量大小的硬盘进行优化。</li>
</ul>
<h3 id="raid-1"><a class="header-anchor" href="#raid-1"></a>RAID 1</h3>
<p>RAID1模式的磁盘阵列的模式为“N+1”，无论有多少个磁盘，它只用其中一个来存储数据，其它每个磁盘都是它的镜像，举个例子：有两个磁盘，那磁盘利用率就是 50%，有 N 个磁盘，那磁盘利用率就是 1/N。</p>
<p><img src="NAS-5/image_VtXfS8z50u.png" alt=""></p>
<ul>
<li>最少需要的硬盘数：2</li>
<li>优点：N 个硬盘冗余</li>
<li>缺点：存储池可用空间被限制为一个硬盘的容量。未针对不同容量大小的硬盘进行优化。</li>
</ul>
<h3 id="raid-5"><a class="header-anchor" href="#raid-5"></a>RAID 5</h3>
<p>RAID 5 技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID 5 磁盘阵列中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上。这样的好处是，其中任一设备损坏后都可以依赖其它几块设备重建丢失的这块硬盘数据。</p>
<p>RAID 5 需要使用至少 3 个驱动器，像 RAID 0 一样跨多个驱动器条带化数据，但也有跨驱动器分布的“奇偶校验”。在单个驱动器发生故障的情况下，使用存储在其他驱动器上的奇偶校验信息将数据拼凑在一起。停机时间为零。读取速度非常快，但由于必须计算奇偶校验，写入速度稍慢。它非常适合数据驱动器数量有限的文件和应用程序服务器。</p>
<p><img src="NAS-5/image_cJcs4zH-qf.png" alt=""></p>
<ul>
<li>需要的硬盘数：3</li>
<li>优点：1 个硬盘的容错机制并将存储空间配置优化</li>
<li>缺点：未针对不同容量大小的硬盘进行优化
<ul>
<li>在磁盘故障的情况下，恢复可能需要更长的时间，因为必须从所有可用驱动器计算奇偶校验</li>
<li>无法承受并发驱动器故障</li>
</ul>
</li>
</ul>
<h3 id="raid-6"><a class="header-anchor" href="#raid-6"></a>RAID 6</h3>
<p>RAID 6 使用双奇偶校验块来实现比 RAID 5 更好的数据冗余，这增加了阵列中最多两个驱动器故障的容错能力。每个磁盘都有两个奇偶校验块，它们存储在阵列中的不同磁盘上，RAID 6 是用于维护高可用性系统的非常实用的基础架构。</p>
<p><img src="NAS-5/image_RCHIYlrrPJ.png" alt=""></p>
<ul>
<li>至少需要 4 个驱动器</li>
<li>优点：2 个硬盘冗余</li>
<li>缺点：由于双重奇偶校验，写入数据需要更长的时间。未针对不同容量大小的硬盘进行优化。</li>
</ul>
<h3 id="raid-10-raid-1-0"><a class="header-anchor" href="#raid-10-raid-1-0"></a>RAID 10（RAID 1+0）</h3>
<p>以上提到的 RAID 均为基本 RAID 级别，而 RAID 10、RAID 50、RAID 60 等属于跨区 RAID 级别。</p>
<p>RAID 10 技术需要至少 4 块硬盘来组建，其中先分别两两制作成 RAID 1 磁盘阵列，以保证数据的安全性；然后再对两个 RAID 1 磁盘阵列实施 RAID 0 技术，进一步提高硬盘设备的读写速度。</p>
<p>这样从理论上来讲，只要坏的不是同一阵列中的所有硬盘，那么最多可以损坏 50%的硬盘设备而不丢失数据。由于 RAID 10 技术继承了 RAID 0 的高读写速度和 RAID 1 的数据安全性，在不考虑成本的情况下 RAID 10 的性能也超过了 RAID 5，因此当前成为广泛使用的一种存储技术。</p>
<p><img src="NAS-5/image_BfXDKEHJ4_.png" alt=""></p>
<h2 id="通过-cockpit-创建软-raid"><a class="header-anchor" href="#通过-cockpit-创建软-raid"></a>通过 Cockpit 创建软 RAID</h2>
<p>如果想使用 ZFS，可以跳过这里直接查看ZFS部分。</p>
<p>通过 Cockpit 创建软 RAID 的过程非常简单，在<code>存储</code>栏找到<code>创建 MDRAID 设备</code>：</p>
<p><img src="NAS-5/image_rXjQ4U5lca.png" alt=""></p>
<p>根据自己的需求选择 RAID 级别及对应磁盘即可。</p>
<p><img src="NAS-5/image_sHTpZSTZAA.png" alt=""></p>
<h1 id="zfs"><a class="header-anchor" href="#zfs"></a>ZFS</h1>
<p>ZFS 被描述为“终极文件系统”，稳定、快速、安全并面向未来。</p>
<p>ZFS 的特点包括：存储池（被称为 “zpool” 的集成卷管理系统）、写时复制、快照、数据完整性校验和自动修复（擦除）、RAID-Z、最大 16 Exabyte 文件大小，以及最大 256×10¹⁵ Zettabyte 存储，且对文件系统（数据集）或文件的数量没有限制 。</p>
<p><img src="NAS-5/image_poj7G05kCN.png" alt=""></p>
<ul>
<li>存储池：与大多数文件系统不同，ZFS 结合了文件系统和卷管理器的特性。这意味着，它与其他文件系统不同，ZFS 可以创建跨越一系列硬盘或池的文件系统。不仅如此，你还可以通过添加硬盘来增大池的存储容量。ZFS 可以进行<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.howtogeek.com/175159/an-introduction-to-the-z-file-system-zfs-for-linux/" title="分区和格式化">分区和格式化</a>。</li>
<li>写时复制：在大多数文件系统上，当数据被重写时，它将永久丢失。而在 ZFS 中，新数据会写到不同的块。写完成之后，更新文件系统元数据信息，使之指向新的数据块。这确保了如果在写新数据的时候系统崩溃（或者发生其它事，比如突然断电），那么原数据将会保存下来。这也意味着，在系统发生崩溃之后，不需要运行 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Fsck" title="fsck">fsck</a> 来检查和修复文件系统。</li>
<li>快照：ZFS 使用快照来跟踪文件系统中的更改。<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.freebsd.org/doc/handbook/zfs-term.html" title="快照">快照</a>包含文件系统的原始版本（文件系统的一个只读版本），实时文件系统则包含了自从快照创建之后的任何更改。没有使用额外的空间。因为新数据将会写到实时文件系统新分配的块上。如果一个文件被删除了，那么它在快照中的索引也会被删除。所以，快照主要是用来跟踪文件的更改，而不是文件的增加和创建。</li>
<li>数据完整性校验和自动修复：当向 ZFS 写入新数据时，会创建该数据的校验和。在读取数据的时候，使用校验和进行验证。如果前后校验和不匹配，那么就说明检测到了错误，然后，ZFS 会尝试自动修正错误。</li>
<li>RAID-Z：ZFS 不需要任何额外软件或硬件就可以处理 RAID。ZFS 有自己的 RAID 实现：RAID-Z 。RAID-Z 是 RAID-5 的一个变种，不过它克服了 RAID-5 的写漏洞：意外重启之后，数据和校验信息会变得不同步。为了使用<a target="_blank" rel="noopener external nofollow noreferrer" href="https://wiki.archlinux.org/index.php/ZFS/Virtual_disks#Creating_and_Destroying_Zpools" title="基本级别的 RAID-Z">基本级别的 RAID-Z</a>（RAID-Z1），你需要至少三块磁盘，其中两块用来存储数据，另外一块用来存储<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.pcmag.com/encyclopedia/term/60364/raid-parity" title="奇偶校验信息">奇偶校验信息</a>。而 RAID-Z2 需要至少两块磁盘存储数据以及两块磁盘存储校验信息。RAID-Z3 需要至少两块磁盘存储数据以及三块磁盘存储校验信息。另外，只能向 RAID-Z 池中加入偶数倍的磁盘，而不能是奇数倍的。</li>
</ul>
<p>ZFS 也存在一些问题：</p>
<ul>
<li>ZFS 采用<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zh.wikipedia.org/wiki/CDDL" title="通用开发与散布许可证">通用开发与散布许可证</a>（CDDL）授权，其与 GPL 不兼容，因此 ZFS <a target="_blank" rel="noopener external nofollow noreferrer" href="https://sfconservancy.org/blog/2016/feb/25/zfs-and-linux/" title="不可能">不可能</a>被纳入 Linux 内核中。然而，这并不妨碍第三方开发者开发并发布原生的 Linux 内核模块，比如 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openzfs.org/" title="OpenZFS">OpenZFS</a> (以前被称为 ZFS on Linux)。这使得 OpenZFS 项目必须主动跟上 Linux 内核版本。</li>
<li>ZFS 使用了自己的 ARC 缓存模型。这带来了更高的缓存命中率，但是这也导致了这部分缓存不在内核的 <code>cached</code> 内存内。因此，当内存不够时，这部分缓存无法被及时的释放。因此，推荐使用 ZFS 的系统准备充足的内存。</li>
</ul>
<h2 id="通过-cockpit-创建-zfs-池"><a class="header-anchor" href="#通过-cockpit-创建-zfs-池"></a>通过 Cockpit 创建 ZFS 池</h2>
<p>通过 Cockpit 创建 ZFS 池的过程非常简单，首先确保你已安装了<code>zfs-dkms</code>、<code>zfsutils-linux</code>包，以及<code>cockpit-zfs-manager</code>管理器。确认相关服务已启动并正常运行（安装完成后需重启）。</p>
<p>在<code>ZFS</code>栏找到<code>Create Storage Pool</code>：</p>
<p><img src="NAS-5/image_9rbj6ZwyQg.png" alt=""></p>
<p>关于 Virtual Device 选项，Disk 代表直接使用这块硬盘，Mirror 代表 RAID 1 级别。</p>
<p><img src="NAS-5/image_8jVVkcub76.png" alt=""></p>
<p>根据自己的需求选择 RAID 级别及对应磁盘即可。</p>
<p>Cockpit 的 ZFS 界面会出现图标不显示的问题。45Drives 表示他们已知晓<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/45Drives/cockpit-zfs-manager/issues/15">此问题</a>并选择忽视，但提供了一个解决此问题的脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Fixing cockpit fonts</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/share/cockpit/base1/fonts</span><br><span class="line"></span><br><span class="line">curl -sSL https://scripts.45drives.com/cockpit_font_fix/fonts/fontawesome.woff -o /usr/share/cockpit/base1/fonts/fontawesome.woff</span><br><span class="line">curl -sSL https://scripts.45drives.com/cockpit_font_fix/fonts/glyphicons.woff -o /usr/share/cockpit/base1/fonts/glyphicons.woff</span><br><span class="line">curl -sSL https://scripts.45drives.com/cockpit_font_fix/fonts/patternfly.woff -o /usr/share/cockpit/base1/fonts/patternfly.woff</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/share/cockpit/static/fonts</span><br><span class="line"></span><br><span class="line">curl -sSL https://scripts.45drives.com/cockpit_font_fix/fonts/OpenSans-Semibold-webfont.woff -o /usr/share/cockpit/static/fonts/OpenSans-Semibold-webfont.woff</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Done</span><br></pre></td></tr></table></figure>
<p>以下内容主要来自<a target="_blank" rel="noopener external nofollow noreferrer" href="https://szclsya.me/zh-cn/posts/storage/zfs-maintenance/" title="这篇博客">这篇博客</a>以及 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/cd/E24847_01/html/819-7065/gavwg.html#scrolltoc" title="Oracle Solaris ZFS 管理指南">Oracle Solaris ZFS 管理指南</a>。</p>
<h2 id="zfs-维护"><a class="header-anchor" href="#zfs-维护"></a>ZFS 维护</h2>
<h3 id="配置定时-scrub"><a class="header-anchor" href="#配置定时-scrub"></a>配置定时 Scrub</h3>
<p>ZFS 拥有自愈特性，但这仅对热数据有效（即经常被读写的数据）。对于冷数据，ZFS 提供了<code>scrubing</code>机制，即定期读取一遍存储池内的所有数据并检验校验和，以发现冷数据中的数据错误。</p>
<p>一般来说，推荐至少每月做一次 scrub。对于消费级硬盘来说，由于数据可靠性相对更低，应考虑更频繁地进行 scrub 操作。很多发行版会随着 ZFS 本身安装定期 scrub 的脚本/服务配置，例如在 Debian 上可以用这些命令开启定期 scrub：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian 上启用每周自动 scrub</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now zfs-scrub-weekly@POOL.timer</span><br><span class="line"><span class="comment"># Debian 上启用每月自动 scrub</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now zfs-scrub-monthly@POOL.timer</span><br></pre></td></tr></table></figure>
<p>对于 Debian 以外的发行版 / OS 则可查询相应的手册或 Wiki。对于使用 systemd 且没有自带脚本的系统，可以使用<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lnicola/systemd-zpool-scrub" title="systemd-zpool-scrub - GitHub">systemd-zpool-scrub - GitHub</a>。</p>
<h3 id="使用快照"><a class="header-anchor" href="#使用快照"></a>使用快照</h3>
<p>由于 ZFS 使用 COW （Copy on Write，写入时复制）策略，对 ZFS 存储池建立快照几乎不需要占用任何空间及计算资源。因此，我们可以频繁建立快照并保留一段时间，这样如果出现了误操作就可以找回之前的版本。注意 ZFS 不仅可以对整个存储池进行快照，也允许对数据集建立快照，因此可以根据数据的用途和重要性建立不同的数据集并选择不同的快照策略，非常实用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 POOL 存储池中的 DATASET 数据集建立名为 test 的快照</span></span><br><span class="line">zfs snapshot POOL/DATASET@<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 对所有 DATASET 以内的数据集也递归地建立快照 (-r)</span></span><br><span class="line">zfs snapshot -r POOL/DATASET@<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 显示所有快照</span></span><br><span class="line">zfs list -t snapshots</span><br><span class="line"><span class="comment"># 显示 POOL 存储池中的 DATASET 数据集的所有快照</span></span><br><span class="line">zfs list -t snapshots POOL/DATASET</span><br></pre></td></tr></table></figure>
<p>在 Cockpit 当中创建快照更为快捷：</p>
<p><img src="NAS-5/image_-r4gMDsU2Y.png" alt=""></p>
<h4 id="访问快照中的个别文件"><a class="header-anchor" href="#访问快照中的个别文件"></a>访问快照中的个别文件</h4>
<p>如果我们只需要某快照中的个别文件，可以在数据集的根目录进入<code>.zfs</code>隐藏目录。这个目录是无法被<code>ls -a</code>看见的，但是可以用<code>cd</code>进入。这个目录内有个<code>snapshot</code>文件夹，其中可直接访问任意快照中的任意文件。</p>
<h4 id="回滚快照"><a class="header-anchor" href="#回滚快照"></a>回滚快照</h4>
<p>如果我们想放弃所有后续更改并回到数据集一个先前的状态，我们可以整体回滚到一个先前的快照上。注意默认情况下我们只能回到最新的一个快照上，如果想回滚多个快照之前的版本则需要<code>-r</code>参数。</p>
<blockquote>
<p><strong>注意！回滚到多个快照之前会销毁回滚到的快照之后所有之后的快照！</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚到最近的快照</span></span><br><span class="line">zfs rollback POOL/DATASET@SNAPSHOT</span><br><span class="line"><span class="comment"># 回滚到多个快照之前。注意！会销毁所有之后的快照！</span></span><br><span class="line">zfs rollback -r POOL/DATASET@SNAPSHOT</span><br></pre></td></tr></table></figure>
<p>在 Cockpit 当中回滚快照：</p>
<p><img src="NAS-5/image_pypxDDbmkh.png" alt=""></p>
<h4 id="自动快照管理"><a class="header-anchor" href="#自动快照管理"></a>自动快照管理</h4>
<p>除了手动在一些关键时间节点打快照外，我们也可以使用一些工具自动管理快照。一般这些工具都能实现定期创建快照，删除旧快照以及对于各个时间段保留一定数量的快照（例如本周的快照每天保留一个，更旧的每月保留一个，再旧的每年保留一个等）。</p>
<p>我们可以使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jimsalterjrs/sanoid" title="Sanoid">Sanoid</a>，ZFS 文件系统的策略驱动型快照管理工具。</p>
<p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install debhelper libcapture-tiny-perl libconfig-inifiles-perl pv lzop mbuffer build-essential git</span><br></pre></td></tr></table></figure>
<p>打包安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/jimsalterjrs/sanoid.git</span><br><span class="line"><span class="built_in">cd</span> sanoid</span><br><span class="line"><span class="comment"># checkout latest stable release or stay on master for bleeding edge stuff (but expect bugs!)</span></span><br><span class="line">git checkout $(git tag | grep <span class="string">&quot;^v&quot;</span> | <span class="built_in">tail</span> -n 1)</span><br><span class="line"><span class="built_in">ln</span> -s packages/debian .</span><br><span class="line">dpkg-buildpackage -uc -us</span><br><span class="line"><span class="built_in">sudo</span> apt install ../sanoid_*_all.deb</span><br></pre></td></tr></table></figure>
<p>启用 Sanoid 计时器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now sanoid.timer</span><br></pre></td></tr></table></figure>
<p>配置 Sanoid 任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/sanoid/sanoid.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pool]</span><br><span class="line">    recursive=zfs       # 递归创建快照</span><br><span class="line">    hourly=48           # 保留最近两天的小时级快照</span><br><span class="line">    daily=14            # 保留最近两周的日级快照</span><br><span class="line">    autosnap=yes        # 自动快照</span><br><span class="line">    autoprune=yes       # 过期快照自动销毁</span><br></pre></td></tr></table></figure>
<p>创建 crontab 任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/crontab</span><br></pre></td></tr></table></figure>
<p>加入如下内容（建议使用 UTC 作为时区，以防止出现夏令时问题）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TZ=UTC</span><br><span class="line">* * * * * root /usr/local/bin/sanoid --cron</span><br></pre></td></tr></table></figure>
<h4 id="备份"><a class="header-anchor" href="#备份"></a>备份</h4>
<blockquote>
<p>mirror / RAIDz 不是 备份！这些手段被称为冗余，只能确保磁盘损坏不会影响数据，而不能保护类似人为因素/软件崩溃/硬件故障等其他灾害情况。永远不要仅依赖冗余保护数据！</p>
</blockquote>
<p>ZFS 上最好的备份方式是定期创建快照，然后把它们发送到备份源中。这种方法最大的优点是快照中的文件历史也能留存下来，且相对而言传输/存储的压力都较小（因为只会传输并存储两个快照中的增量数据）。备份源可以是另一个 ZFS 存储池（可以是本地的，也可以在网络上的），也可以作为文件存储在别的介质上（例如光或磁带存储介质）。一个常见的做法是定期接上一块备份移动硬盘并将最新的快照发送到这块盘的存储池上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将快照发送至本地的另一个存储池</span></span><br><span class="line">zfs send <span class="built_in">source</span>/dataset@snapshot | zfs recv backup/dataset</span><br><span class="line"><span class="comment"># 通过 SSH 将快照发送到网络上的另一个存储池</span></span><br><span class="line">zfs send <span class="built_in">source</span>/dataset@snapshot | ssh remote.ip zfs recv backup/dataset</span><br><span class="line"><span class="comment"># 仅发送 snap1 和 snap2 中的增量数据</span></span><br><span class="line">zfs send <span class="built_in">source</span>/dataset@snap1 <span class="built_in">source</span>/dataset@snap2 | ssh remote.ip zfs recv backup/dataset</span><br></pre></td></tr></table></figure>
<p>和打快照一样，发送快照也可以被自动化。许多快照管理软件要么可以和同步软件协同，要么直接内置了数据同步工具。例如之前提到的 Sanoid 就内置了名为<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jimsalterjrs/sanoid?tab=readme-ov-file#syncoid" title="syncoid">syncoid</a>的同步工具。如果你用的不是 Sanoid 的话，快照软件的文档里一般也会介绍如何使用他们内置的同步工具，或如何与外部的同步软件协同。</p>
<h2 id="zfs-灾难恢复"><a class="header-anchor" href="#zfs-灾难恢复"></a>ZFS 灾难恢复</h2>
<h3 id="存储池故障"><a class="header-anchor" href="#存储池故障"></a>存储池故障</h3>
<p>运气不太好，存储池真的坏了。现在怎么办？</p>
<p>首先我们得知道到底发生了什么。我们可以使用<code>zpool status</code>命令来查看存储池的状态。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 常见的由突然断电导致的读写错误</span><br><span class="line">  pool: data</span><br><span class="line"> state: DEGRADED</span><br><span class="line">status: One or more devices has experienced an unrecoverable error.  An</span><br><span class="line">        attempt was made to correct the error.  Applications are unaffected.</span><br><span class="line">action: Determine if the device needs to be replaced, and clear the errors</span><br><span class="line">        using &#x27;zpool clear&#x27; or replace the device with &#x27;zpool replace&#x27;.</span><br><span class="line">   see: https://openzfs.github.io/openzfs-docs/msg/ZFS-8000-9P</span><br><span class="line">  scan: none requested</span><br><span class="line"></span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME                      STATE     READ WRITE CKSUM</span><br><span class="line">        data                      DEGRADED     0     0     0</span><br><span class="line">          ata-VOLUME-1            DEGRADED    13     0     0  too many errors</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure>
<p>最常见的故障有存储盘下线和读写错误过多。有时突然断电就会导致出现读写错误，但这种故障通常是软件层面的，硬盘本身没有问题。如果硬盘本身真的没问题的话，我们仅需让 ZFS 忽略这次事故即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们仅需清零错误计数器即可</span></span><br><span class="line">zpool clear data</span><br></pre></td></tr></table></figure>
<p>另一种可能则是硬盘的确有问题。在这种情况下就最好在硬盘完全失效前换上一块好硬盘了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用好硬盘 (ata-GOOD) 换下已知有问题的硬盘 (ata-FAULTY)</span></span><br><span class="line"><span class="comment"># 如果是简单卷的话 ZFS 会自动进入重新构建 RAID 的过程（称为 resilvering）并将旧硬盘的数据复制到新盘上</span></span><br><span class="line"><span class="comment"># 如果是在 mirror/RAIDz 中的话 ZFS 会重建阵列</span></span><br><span class="line">zpool replace POOL ata-FAULTY ata-GOOD</span><br></pre></td></tr></table></figure>
<h3 id="数据损坏"><a class="header-anchor" href="#数据损坏"></a>数据损坏</h3>
<p>如果前期冗余留的足够的话，大多数情况下 ZFS 都能从冗余盘中重构数据并正常运行（并如前文所示报告读写错误）。但如果冗余不足以重构数据，我们就遇上了数据损坏。与传统 RAID 不同的是，ZFS 可以精确告诉我们哪些文件卷入了数据损坏中：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pool: data</span><br><span class="line"> state: ONLINE</span><br><span class="line">status: One or more devices has experienced an unrecoverable error.  An</span><br><span class="line">        attempt was made to correct the error.  Applications may be affected.</span><br><span class="line">action: Restore the file in question if possible.  Otherwise restore the</span><br><span class="line">        entire pool from backup.</span><br><span class="line">   see: https://openzfs.github.io/openzfs-docs/msg/ZFS-8000-8A</span><br><span class="line">  scan: none requested</span><br><span class="line"></span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME                      STATE     READ WRITE CKSUM</span><br><span class="line">        data                      ONLINE       0     0     0</span><br><span class="line">          ata-VOLUME-1            ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: Permanent errors have been detected in the following files:</span><br><span class="line"></span><br><span class="line">        [REDACTED]</span><br></pre></td></tr></table></figure>
<p>在这种情况下备份（希望有！）就派上用场了。考虑换下出问题的盘并增加冗余量，以防这种事件再次发生。</p>
<h3 id="根系统故障-存储池迁移"><a class="header-anchor" href="#根系统故障-存储池迁移"></a>根系统故障 / 存储池迁移</h3>
<p>在先前的配置中，我们创建了挂载在根文件系统（非 ZFS，如 Ext4 / Btrfs / XFS 等）下的 ZFS 存储池。如果根文件系统损坏，我们该如何读取 ZFS 存储池当中的数据呢？</p>
<p>首先，应从 LiveCD 启动以尝试直接恢复原系统。尝试从恢复备份、更新软件包、修复引导等方面入手。</p>
<p>如果实在陷入绝境，只能舍弃系统，转而寻求存储池中的数据。基于此，我们可以参考存储池迁移部分。</p>
<blockquote>
<p>有时，可能需要在系统之间移动存储池。为此，必须将存储设备与原始系统断开，然后将其重新连接到目标系统。可以通过以下方法完成此任务：以物理方式重新为设备布线，或者使用多端口设备（如 SAN 中的设备）。使用 ZFS 可将池从一台计算机中导出，然后将其导入目标系统，即使这该系统采用不同的字节存储顺序 (endianness)。</p>
</blockquote>
<h4 id="准备迁移-zfs-存储池"><a class="header-anchor" href="#准备迁移-zfs-存储池"></a>准备迁移 ZFS 存储池</h4>
<p>应显式导出存储池，以表明可随时将其迁移。此操作会将任何未写入的数据刷新到磁盘，将数据写入磁盘以表明导出已完成，并从系统中删除有关池的所有信息。</p>
<p>如果不显式导出池，而是改为手动删除磁盘，则仍可以在其他系统中导入生成的池。但是，可能会丢失最后几秒的数据事务，并且由于设备不再存在，该池在原始系统中可能会显示为处于故障状态。缺省情况下，目标系统无法导入未显式导出的池。为防止意外导入包含仍在其他系统中使用的网络连接存储器的活动池，此条件是必要的。</p>
<h4 id="导出-zfs-存储池"><a class="header-anchor" href="#导出-zfs-存储池"></a>导出 ZFS 存储池</h4>
<p>要导出池，请使用zpool export命令。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zpool <span class="built_in">export</span> tank</span><br></pre></td></tr></table></figure>
<p>此命令将尝试取消挂载池中任何已挂载的文件系统，然后再继续执行。如果无法取消挂载任何文件系统，则可以使用<code>-f</code>选项强制取消挂载这些文件系统。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; zpool <span class="built_in">export</span> tank</span><br><span class="line">cannot unmount <span class="string">&#x27;/export/home/xxx&#x27;</span>: Device busy</span><br><span class="line">&gt; zpool <span class="built_in">export</span> -f tank</span><br></pre></td></tr></table></figure>
<p>执行此命令后，池 tank 在系统中即不再可见。</p>
<p>如果在导出时设备不可用，则无法将设备标识为正常导出。如果之后将某个这样的设备附加到不包含任何工作设备的系统中，则该设备的状态会显示为“可能处于活动状态”。</p>
<p>如果 ZFS 卷在池中处于使用状态，即使使用<code>-f</code>选项，也无法导出池。要导出包含 ZFS 卷的池，请首先确保卷的所有使用者都不再处于活动状态。</p>
<h4 id="确定要导入的可用存储池"><a class="header-anchor" href="#确定要导入的可用存储池"></a>确定要导入的可用存储池</h4>
<p>从系统中删除池后（通过显式导出或通过强制删除设备），可以将设备附加到目标系统。ZFS 可以处理仅有其中一些设备可用的情况，但池迁移成功与否取决于设备的整体运行状况。此外，没有必要使用相同的设备名称附加设备。ZFS 可检测任何移动的或重命名的设备，并相应地调整配置。要搜索可用的池，请运行不带任何选项的<code>zpool import</code>命令。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; zpool import</span><br><span class="line"> pool: tank</span><br><span class="line">    <span class="built_in">id</span>: 11809215114195894163</span><br><span class="line"> state: ONLINE</span><br><span class="line">action: The pool can be imported using its name or numeric identifier.</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        tank        ONLINE</span><br><span class="line">          mirror-0  ONLINE</span><br><span class="line">            c1t0d0  ONLINE</span><br><span class="line">            c1t1d0  ONLINE</span><br></pre></td></tr></table></figure>
<p>与<code>zpool status</code> 命令输出类似，<code>zpool import</code> 输出也会包括一个知识文章链接，其中包含有关禁止导入池这一问题的修复过程的最新信息。在此示例中，用户可以强制导入池。但是，如果导入当前正由其他系统通过存储网络使用的池，则可能导致数据损坏和出现紧急情况，因为这两个系统都尝试写入同一存储器。如果池中的某些设备不可用，但是存在足够的冗余数据可确保池可用，则池会显示 DEGRADED 状态。</p>
<h4 id="导入-zfs-存储池"><a class="header-anchor" href="#导入-zfs-存储池"></a>导入 ZFS 存储池</h4>
<p>确定要导入的池后，即可通过将该池的名称或者其数字标识符指定为<code>zpool import</code>命令的参数来将其导入。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zpool import tank</span><br></pre></td></tr></table></figure>
<p>如果池未正常导出，则 ZFS 需要使用<code>-f</code>标志，以防止用户意外导入仍在其他系统中使用的池。如果遇到根系统故障无法恢复的情况，我们就需要强制导入。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; zpool import dozer</span><br><span class="line">cannot import <span class="string">&#x27;dozer&#x27;</span>: pool may be <span class="keyword">in</span> use on another system</span><br><span class="line">use <span class="string">&#x27;-f&#x27;</span> to import anyway</span><br><span class="line">&gt; zpool import -f dozer</span><br></pre></td></tr></table></figure>
<p>关于更多信息，请参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/cd/E24847_01/html/819-7065/gbchy.html" title="Oracle Solaris ZFS 管理指南 - 迁移 ZFS 存储池">Oracle Solaris ZFS 管理指南 - 迁移 ZFS 存储池</a>。</p>
<br/>
<a href="/NAS-6" title="NAS（6）—— SMB &amp; WebDAV">下一章节：SMB &amp; WebDAV</a></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.dawnocean.site">Dean Ma</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.dawnocean.site/NAS-5">https://blog.dawnocean.site/NAS-5</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.dawnocean.site" target="_blank">Dean's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/assets/img/kirby_cover20.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/NAS-6" title="NAS（6）—— SMB &amp; WebDAV"><img class="cover" src="/assets/img/default_cover3.JPEG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NAS（6）—— SMB & WebDAV</div></div><div class="info-2"><div class="info-item-1">回到目录  概述 经过前面几个模块的配置，我们已经能够在 NAS 上存放我们的数据，并且通过组建 RAID 与接入 UPS 等方式加强了数据存储的安全性。在这个部分，我们需要通过配置来实现通过各种设备来访问 NAS 中存储的数据，并且进一步加强数据存储的安全性。 SMB / Samba SMB（Server Message Block）可用于在计算机间共享文件、打印机、串口等，电脑上的网上邻居就是靠它实现的。通过 SMB 协议，客户端应用程序可以在各种网络环境下读、写服务器上的文件，以及对服务器程序提出服务请求。此外通过 SMB 协议，应用程序可以访问远程服务器端的文件、以及打印机等资源。 Samba 能让 Linux 服务器实现文件服务器、身份授权和认证、名称解析和打印服务等功能。 Samba 也是 SMB 协议的实现，它允许 Windows 客户访问 Linux 系统上的目录、打印机和文件（就像访问 Windows 服务器时一样）。重要的是，Samba 可以将 Linux 服务器构建成一个域控制器。这样一来，就可以直接使用 Windows 域中的用户凭据，免去手动在 Linu...</div></div></div></a><a class="pagination-related" href="/NAS-4" title="NAS（4）—— UPS 不断电系统"><img class="cover" src="/assets/img/kirby_cover8.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">NAS（4）—— UPS 不断电系统</div></div><div class="info-2"><div class="info-item-1">回到目录  UPS 笔者可以很负责任地说：如果你组建的 NAS 有数据存储需求，那么一定需要一同配备一台 UPS（Uninterruptible Power Supply，不间断电源）。在遇到突发情况导致断电时，UPS 可以保证继续维持一段时间的稳定供电。此时，UPS 可以通过 USB 连接等方式向 NAS 发送低电量（离电）信号，NAS 在接收到这个信号后进行自动关机，从而保护其中的数据。 关于 UPS 选购的部分，本文不作说明，满足以下要求即可：  保证在突然断电时能够维持一段时间的稳定供电 保证处于供电状态时能够向机器发送信号  停电告警 通过 USB 连接到 UPS 一般在购买时 UPS 会随机器附赠一条 USB Type-B 线，将其与 NAS 连接起来即可。 将 NAS 的电源插头插到 UPS 上，在终端中输入如下命令： 1lsusb 以查看连接到 NAS 的 USB 设备。结果如下所示： 123Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 008: ID 07...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Dean Ma</div><div class="author-info-description">晓洋的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Dawn1Ocean" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #000000;"></i></a><a class="social-icon" href="mailto:dawn_ocean@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E5%81%A5%E5%BA%B7%E7%9B%91%E6%B5%8B"><span class="toc-number">1.</span> <span class="toc-text">硬盘健康监测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#smart"><span class="toc-number">1.1.</span> <span class="toc-text">SMART</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scrutiny"><span class="toc-number">1.2.</span> <span class="toc-text">Scrutiny</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-docker-%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">通过 Docker 部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD"><span class="toc-number">2.</span> <span class="toc-text">系统备份</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#snapper-btrfs"><span class="toc-number">2.1.</span> <span class="toc-text">Snapper - Btrfs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%BF%AB%E7%85%A7%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.1.2.</span> <span class="toc-text">改变快照存储位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text">创建快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E5%BF%AB%E7%85%A7-%E4%BB%85%E7%94%A8%E4%BA%8E%E9%9D%9E%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">2.1.4.</span> <span class="toc-text">回滚快照（仅用于非根目录）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E5%88%B0%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.5.</span> <span class="toc-text">备份到外部存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%BF%AB%E7%85%A7%E6%81%A2%E5%A4%8D"><span class="toc-number">2.1.6.</span> <span class="toc-text">从快照恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#timeshift-%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Timeshift - 所有文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7"><span class="toc-number">2.2.2.</span> <span class="toc-text">创建快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%BF%AB%E7%85%A7%E6%81%A2%E5%A4%8D"><span class="toc-number">2.2.3.</span> <span class="toc-text">从快照恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#raid"><span class="toc-number">3.</span> <span class="toc-text">RAID</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF-raid-%E5%92%8C%E7%A1%AC-raid"><span class="toc-number">3.1.</span> <span class="toc-text">软 RAID 和硬 RAID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raid-%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">RAID 种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#raid-0"><span class="toc-number">3.2.1.</span> <span class="toc-text">RAID 0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">RAID 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid-5"><span class="toc-number">3.2.3.</span> <span class="toc-text">RAID 5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid-6"><span class="toc-number">3.2.4.</span> <span class="toc-text">RAID 6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raid-10-raid-1-0"><span class="toc-number">3.2.5.</span> <span class="toc-text">RAID 10（RAID 1+0）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-cockpit-%E5%88%9B%E5%BB%BA%E8%BD%AF-raid"><span class="toc-number">3.3.</span> <span class="toc-text">通过 Cockpit 创建软 RAID</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zfs"><span class="toc-number">4.</span> <span class="toc-text">ZFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-cockpit-%E5%88%9B%E5%BB%BA-zfs-%E6%B1%A0"><span class="toc-number">4.1.</span> <span class="toc-text">通过 Cockpit 创建 ZFS 池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zfs-%E7%BB%B4%E6%8A%A4"><span class="toc-number">4.2.</span> <span class="toc-text">ZFS 维护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6-scrub"><span class="toc-number">4.2.1.</span> <span class="toc-text">配置定时 Scrub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BF%AB%E7%85%A7"><span class="toc-number">4.2.2.</span> <span class="toc-text">使用快照</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%BF%AB%E7%85%A7%E4%B8%AD%E7%9A%84%E4%B8%AA%E5%88%AB%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">访问快照中的个别文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E5%BF%AB%E7%85%A7"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">回滚快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%BF%AB%E7%85%A7%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">自动快照管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">备份</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zfs-%E7%81%BE%E9%9A%BE%E6%81%A2%E5%A4%8D"><span class="toc-number">4.3.</span> <span class="toc-text">ZFS 灾难恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%B1%A0%E6%95%85%E9%9A%9C"><span class="toc-number">4.3.1.</span> <span class="toc-text">存储池故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8D%9F%E5%9D%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">数据损坏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C-%E5%AD%98%E5%82%A8%E6%B1%A0%E8%BF%81%E7%A7%BB"><span class="toc-number">4.3.3.</span> <span class="toc-text">根系统故障 &#x2F; 存储池迁移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E8%BF%81%E7%A7%BB-zfs-%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">准备迁移 ZFS 存储池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA-zfs-%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">导出 ZFS 存储池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E8%A6%81%E5%AF%BC%E5%85%A5%E7%9A%84%E5%8F%AF%E7%94%A8%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">确定要导入的可用存储池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-zfs-%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">导入 ZFS 存储池</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/NAS-1-1" title="NAS（1-1）—— 成品 NAS 配置（QNAP）"><img src="/assets/img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NAS（1-1）—— 成品 NAS 配置（QNAP）"/></a><div class="content"><a class="title" href="/NAS-1-1" title="NAS（1-1）—— 成品 NAS 配置（QNAP）">NAS（1-1）—— 成品 NAS 配置（QNAP）</a><time datetime="2025-08-17T14:46:10.000Z" title="发表于 2025-08-17 22:46:10">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/uv" title="uv：新一代 Python 虚拟环境管理工具"><img src="/assets/img/default_cover4.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="uv：新一代 Python 虚拟环境管理工具"/></a><div class="content"><a class="title" href="/uv" title="uv：新一代 Python 虚拟环境管理工具">uv：新一代 Python 虚拟环境管理工具</a><time datetime="2025-07-15T08:04:27.000Z" title="发表于 2025-07-15 16:04:27">2025-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/nn-3" title="神经网络学习笔记（3）—— 激活函数"><img src="/assets/img/default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="神经网络学习笔记（3）—— 激活函数"/></a><div class="content"><a class="title" href="/nn-3" title="神经网络学习笔记（3）—— 激活函数">神经网络学习笔记（3）—— 激活函数</a><time datetime="2025-06-28T16:28:47.000Z" title="发表于 2025-06-29 00:28:47">2025-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/nn-2" title="神经网络学习笔记（2）—— 前向传播与反向传播的数学推导"><img src="/assets/img/kirby_cover16.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="神经网络学习笔记（2）—— 前向传播与反向传播的数学推导"/></a><div class="content"><a class="title" href="/nn-2" title="神经网络学习笔记（2）—— 前向传播与反向传播的数学推导">神经网络学习笔记（2）—— 前向传播与反向传播的数学推导</a><time datetime="2025-06-28T16:26:13.000Z" title="发表于 2025-06-29 00:26:13">2025-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/nn-1" title="神经网络学习笔记（1）—— MLP"><img src="/assets/img/kirby_cover19.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="神经网络学习笔记（1）—— MLP"/></a><div class="content"><a class="title" href="/nn-1" title="神经网络学习笔记（1）—— MLP">神经网络学习笔记（1）—— MLP</a><time datetime="2025-06-28T16:24:47.000Z" title="发表于 2025-06-29 00:24:47">2025-06-29</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By Dean Ma</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Dawn1Ocean/giscus',
      'data-repo-id': 'R_kgDOLniK6Q',
      'data-category-id': 'DIC_kwDOLniK6c4CeVy2',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>